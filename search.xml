<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[windows下安装yii]]></title>
      <url>%2F2017%2F06%2F01%2Fyii-install%2F</url>
      <content type="text"><![CDATA[通过 Composer 安装 Packagist / Composer中国全量镜像先安装 Composer安装前请务必确保已经正确安装了 PHP。打开命令行窗口并执行 php -v 查看是否正确输出版本号。打开命令行并依次执行下列命令安装最新版本的 Composer： 1php -r &quot;copy(&apos;https://install.phpcomposer.com/installer&apos;, &apos;composer-setup.php&apos;);&quot; 1php composer-setup.php 1php -r &quot;unlink(&apos;composer-setup.php&apos;);&quot; 说明：执行第一条命令下载下来的 composer-setup.php 脚本将简单地检测 php.ini 中的参数设置，如果某些参数未正确设置则会给出警告；然后下载最新版本的 composer.phar 文件到当前目录。 上述 3 条命令的作用依次是： 下载安装脚本 － composer-setup.php － 到当前目录。执行安装过程。删除安装脚本。 全局安装全局安装是将 Composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。 Mac 或 Linux 系统：打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面： 1# sudo mv composer.phar /usr/local/bin/composer Windows 系统：1、找到并进入 PHP 的安装目录（和你在命令行中执行的 php 指令应该是同一套 PHP）。2、将 composer.phar 复制到 PHP 的安装目录下面，也就是和 php.exe 在同一级目录。3、在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。 1@php &quot;%~dp0composer.phar&quot; %* 最后重新打开一个命令行窗口试一试执行 composer –version 看看是否正确输出版本号。如图所示： 提示：不要忘了经常执行 composer selfupdate 以保持 Composer 一直是最新版本哦！ 1composer selfupdate //命令行中执行 Packagist 镜像使用方法系统全局配置： 即将配置信息添加到 Composer 的全局配置文件 config.json 中。见“方法一”单个项目配置： 将配置信息添加到某个项目的 composer.json 文件中。见“方法二” 方法一： 修改 composer 的全局配置文件（推荐方式）打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令： 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 方法二： 修改当前项目的 composer.json 配置文件：打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令： 1composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）：“repositories”: { “packagist”: { “type”: “composer”, “url”: “https://packagist.phpcomposer.com“ }} 镜像原理：一般情况下，安装包的数据（主要是 zip 文件）一般是从 github.com 上下载的，安装包的元数据是从 packagist.org 上下载的。 然而，由于众所周知的原因，国外的网站连接速度很慢，并且随时可能被“墙”甚至“不存在”。 “Packagist 中国全量镜像”所做的就是缓存所有安装包和元数据到国内的机房并通过国内的 CDN 进行加速，这样就不必再去向国外的网站发起请求，从而达到加速 composer install 以及 composer update 的过程，并且更加快速、稳定。因此，即使 packagist.org、github.com 发生故障（主要是连接速度太慢和被墙），你仍然可以下载、更新安装包。 开始使用Composer 安装yii打开命令行，切换到一个可通过 Web 访问的目录（如我的是d:wamp/www），执行如下命令即可安装 Yii ： 123composer global require &quot;fxp/composer-asset-plugin:^1.2.0&quot;composer create-project --prefer-dist yiisoft/yii2-app-basic yiishop 第一条命令安装 Composer asset plugin， 它是通过 Composer 管理 bower 和 npm 包所必须的，此命令全局生效，一劳永逸。 第二条命令会将 Yii 安装在名为 yiishop 的目录中。如果你想使用其它目录名称，你可以选择其他目录名称。 注意: 在安装过程中 Composer 可能会询问你 GitHub 账户的认证信息，因为可能在使用中超过了 GitHub API （对匿名用户的）使用限制。因为 Composer 需要为所有扩展包从 GitHub 中获取大量信息，所以超限非常正常。（译注：也意味着作为程序猿没有 GitHub 账号，就真不能愉快地玩耍了）登陆 GitHub 之后可以得到更高的 API 限额，这样 Composer 才能正常运行。 如下图所示： 我们需要提供一个githtb token 供Composer检索使用具体操作：进入 https://github.com/settings/tokens 点击 「Generate new token」 新建一个 Token，选择默认新建就行，然后就会得到一个 Token，然后输入这个值就 OK 了。 最后等待就可以了，安装成功如下图： 学习yii中文社区]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[memcache 内存缓存技术]]></title>
      <url>%2F2017%2F05%2F05%2Fmemcache%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[coreseek中文检索引擎]]></title>
      <url>%2F2017%2F05%2F04%2Fcoreseek%2F</url>
      <content type="text"><![CDATA[在 Centos6.5 上编译安装coreseek以及配置 下载对应安装包，并解压1# tar zxvf coreseek-3.2.14.tar.gz 先进入mmseg-3.2.14目录安装中文分词1234# ls# cd coreseek-3.2.14/mmseg-3.2.14///检测环境配置是否会报错# ./configure --prefix=/usr/local/mmseg 编译过程中报了一个config.status:error:cannot find input file:src/Makeefile.in这个的错误，然后运行以下指令再次编译就能通过了 1234567891011# aclocal# libtoolize --force# automake --add-missing# autoconf# autoheader# make clean# ./configure --prefix=/usr/local/mmseg//开始编译# make//进行安装# make install 到这里就安装完了mmseg 先进入csft-3.2.14目录安装csft1234567# ls# cd csft-3.2.14///检测环境配置是否会报错# ./configure --prefix=/usr/local/coreseek --with-mysql=/usr/local/mysql --with-mmseg=/usr/local/mmseg --with-mmseg-includes=/usr/local/mmseg/include/mmseg/ --with-mmseg-libs=/usr/local/mmseg/lib/# make# make install 到这里就安装完了csft 配置coreseek1234//进入配置目录# cd /usr/local/coreseek/etc//复制一份配置文件并改名为csft.conf，因为coreseek默认加载的配置文件是csft.conf# cp sphinx.conf.dist csft.conf vim csft.conf，修改为：如下图： 创建全文索引配置文件没有错误了，就可以开始创建全文索引了 1# /usr/local/coreseek/bin/indexer --all 用PHP连接使用Sphinx1、先到http://pecl.php.net/package/sphinx下载所需要的扩展库2、解压文件和进入解压目录 12# tar zxvf sphinx-1.3.3.tgz# cd sphinx-1.3.3 3、调用phpize，生成configure 12//注意此处是你服务器上php安装的地址# /usr/local/php/bin/phpize 4、检测环境配置 1# ./configure --with-php-config=/usr/local/php/bin/php-config --with-sphinx 报错，如下图：5、进入以下目录(之前coreseek-3.2.14的解压目录) 123# cd /usr/local/src/coreseek-3.2.14/csft-3.2.14/api/libsphinxclient# ./configure# make &amp;&amp; make install 6、重新到sphinx-1.3.3目录下执行 123# cd /usr/local/src/sphinx-1.3.3# ./configure --with-php-config=/usr/local/php/bin/php-config --with-sphinx# make &amp;&amp; make install 执行结果如下图：7、修改php下php.ini文件 1# vim /usr/local/php/etc/php.ini …….; For example, on Windows:;; extension=msql.dll;; … or under UNIX:;; extension=msql.soextension=sphinx.so //添加如下这行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb-php结合开发]]></title>
      <url>%2F2017%2F05%2F03%2Fmongodb-php%2F</url>
      <content type="text"><![CDATA[想要在PHP中调用mongobd需要安装mongodb的php扩展 下载最新的php mongodb扩展源码http://pecl.php.net/package/mongo 把扩展编译到php中12345678910111213//先解压文件# tar xzf mongo-1.2.6.tgz//进入解压后的目录# cd mongo-1.2.6//运行phpize来准备编译扩展环境# /usr/local/php/bin/phpize//查看编译参数# ./configure -h//开始编译(--with-php-config参数是告诉配置脚本php-cofig这个程序的路径)# ./configure --with-php-config=/usr/local/php/bin/php-config --enable-mongo//安装# make &amp;&amp; make install //打开配置文件php.ini，把mongodb模块打开（即增加extension=mongo.so）vim /usr/local/php/etc/php.ini….extension=msql.soextension=mongo.so 接下来重启apache 1# /usr/local/apache2/bin/apachect1 restart 最后查看php是否已经支持mongodb 1# cd /usr/local/apache2/htdocs/ vim phpinfo.php&lt;?phpphpinfo();最后浏览器访问该页面，搜索mongo，看是否有 实际操作在php的mongo扩展中，提供了4类接口(对象)：1、针对mongodb连接的操作：Mongo2、针对mongodb中数据库的操作：MongoDB3、针对mongodb中collection的操作：MongoCollection4、针对查询结果集的操作：MongoCursor PHP连接mongodb数据库文件conn.php的内容：&lt;?php$conn = new Mongo(‘mongodb://test1:123@localhost:27017/test’);$db = $conn-&gt;test;?&gt; 查询数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;根据地址栏传过来_id查询数据//db.c1.find({_id:ObjectId(“dfd1dfjfkee”)});$oid = $_GET[‘oid’];$objectId = new MongoId($oid);$arr = array(‘_id’=&gt;$objectId);$rs = $c1-&gt;find($arr);var_dump($rs);$conn-&gt;close(); //关闭连接 增加数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;//db.c1.insert({name:”user1000”});$arr = array(‘name’=&gt;’user1000’);if($c1-&gt;insert($arr)){ echo “插入成功！”;}else{ echo “插入失败！”;}$conn-&gt;close(); //关闭连接 删除数据&lt;?phpinclude “conn.php”;$c1 = $db-&gt;c1;//db.c1.remove({name:”user1000”});$arr = array(‘name’=&gt;’user1000’);if($c1-&gt;remove($arr)){ echo “删除成功！”;}else{ echo “删除失败！”;}$conn-&gt;close(); //关闭连接 修改数据&lt;?phpinclude ‘conn.php’;$c1 = $db-&gt;c1;//db.c1.update({name:”user1”}, {$set:{name:”user100”,sex:1}});$sarr = array(‘name’=&gt;’user1’);$darr = array(‘$set’=&gt;array(‘name’=&gt;’user100’, ‘sex’=&gt;1));$opts = array(‘upsert’=&gt;0, ‘multiple’=&gt;1);if($c1-&gt;update($sarr, $darr, $opts)){ echo “修改成功！”;}else{ echo “修改失败！”;}$conn-&gt;close(); //关闭连接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb数据库一些简单操作]]></title>
      <url>%2F2017%2F05%2F02%2Fmongodb-operation%2F</url>
      <content type="text"><![CDATA[mongodb一些基本操作 进入(登录)客户端操作1# /usr/local/mongodb/bin/mongo 控制台(客户端)中的基本操作命令切换数据库：use test;显式创建数据库：db.createCollection(“a1”);查看当前操作的数据库：db;查看用户列表：db.system.users.find();查看所有用户：show users;查看所有数据库：show dbs;查看所有集合：show collections;删除当前数据库：db.dropDatabase();删除集合：db.user.drop(); //删除user集合想知道mongodb支持哪些命令：help;想知道当前数据库支持哪些方法：db.help();想知道当前集合支持哪些方法：db.user.help(); //查看user集合支持的方法终端清屏：cls 集合的增删改查操作查询user集合的记录db.user.find(); //查询全部记录db.user.find({name:”vonfly”}); //查询name为vonfly的记录db.user.findOne({name:”vonfly”}); //查询name为vonfly的第一条记录 向user集合插入一条记录db.user.insert({name:”vonfly”}); 修改记录(把name为vonfly的修改name为test)db.user.update({name:”vonfly”}, {$set: {name:”test”} }); 删除记录db.user.remove({name:”vonfly”}); //删除name为vonfly的记录db.user.remove(); //删除全部记录 增删改查的高级应用Capped Collectioin(固定集合)属性及用法属性1：对固定集合进行插入速度极快属性2：按照插入顺序的查询输出速度极快属性3：能够在插入最新数据时，淘汰最早的数据 用法1：储存日志信息用法2：缓存一些少量的文档 固定集合的创建（需要显式创建）//创建一个集合为vn_user的固定集合，大小为10000字节。还可以限定文档个数，加上max:100属性db.createCollection(“vn_user”, {capped:true, size:10000});注意：指定文档上限，必须指定大小。文档限制是在容量没满时进行淘汰，要是满了，就根据容量限制来进行淘汰 普通集合转换成固定集合db.runCommand({converTocapped:”test”, size:10000}); //把test普通集合转换成固定集合，大小为10000字节 自然排序固定集合文档按照插入顺序储存的，默认情况下查询就是按照插入顺序返回的，可以使用$natural调整返回顺序db.my_collection.find().sort({“$natural”: 1}); //1表示默认顺序，-1则相反 判断是否为固定集合db.test.isCapped(); //判断test集合是否为固定集合db.test.stats(); //或者用此命令，对应”capped”:1就是固定集合 GridFS大文件管理（使用mongofiles二进制程序）GridFS是一种在mongodb中存储大二进制文件的机制。GridFS使用两个表来存储数据：其中files是包含数据对象；chunks是包含其他一些相关信息的二进制块。使用的原因：1、储存巨大的文件，比如视频、高清图片等2、利用GridFS可以简化需求。3、GridFS可以避免用户上传内容的文件系统出现问题4、GridFS故障恢复和扩展很容易5、GridFS不产生磁盘碎片 查看mongofiles支持对应的参数 1# # /usr/local/mongodb/bin/mongofiles -h 上传文件 1# /usr/local/mongodb/bin/mongofiles put test.tar.gz 进入客户端，查看集合，会发现多了两个集合，fs.chunks和fs.files 下载文件 1# /usr/local/mongodb/bin/mongofiles get test.tar.gz 性能优化查看查询语句的执行计划(类似查看mysql语句执行所用的时间和影响的行数，目的就是要对语句进行优化，看需不需要建立索引)，使用以下语句进行查看 db.user.find({name:”user1”}).explain(); 建立索引（普通索引）//在user集合的name上建立索引db.user.ensureIndex({name:1}); //值1表示升序建立，-1表示降序建立索引 注意：当系统已经有大量数据时，创建索引会非常耗时，需要在后台执行，所以要指定参数background:truedb.user.ensureIndex({name:1}, {background:true}); 创建唯一索引db.user.ensureIndex({name:1}, {unique:true}); 简单查看索引db.user.getIndexKeys(); 查看索引详细信息db.user.getIndexes(); 删除索引//删除user集合中的所有索引db.user.dropIndexes(); //删除user集合中的name索引db.user.dropIndex({name:1}); 优化器profile(慢查询日志功能)mongodb database profiler 是一种慢查询日志功能，可以作为我们优化数据库的依据。 开启profile功能级别的值为：0表示不开启，1表示慢命令(默认为&gt;100ms)，2表示记录所有命令 方法1：启动mongodb时加上–profile=1 方法2：在客户端调用db.setProfilingLevel(级别)命令来实时配置 说明：1、profile信息是保存在system.profile中。我们可以通过db.getProfilingLevel()命令来获取当前的Profile级别2、profile在级别为1时会记录慢命令，默认的慢查询时间为100ms，修改默认时间有两种方法：一种是启动mongodb时加上–profile=1和–slowms=10； 第二种方式是用命令db.setProfilingLevel(1)，表示如果查询耗时超过10毫秒，就会被记录下来3、数据库profiler把数据写入 system.profile 集合中，该集合是一个 capped collection 。可以用普通的MongoDB查询语句查询 system.profile 集合得到profiler的输出。 优化总结1、创建索引，在查询条件的字段上，或者排序条件的字段上创建索引，可以提高执行效率，如db.user.ensureIndex({name:1});2、限定返回结果条数，使用limit()限定返回结果集的大小，可以减少database server的资源消耗，可以减少网络传输数据量。如db.user.find().limit(10);3、查询使用到的字段，不要查询所有字段。如db.user.find({}, {name:1,age:1}).sort({age:-1}).limit(10);4、采用cappedcollection(固定集合)，capped Collections比普通Collections的读写效率高5、采用profiling(慢查询日志功能)，profiling功能肯定是会影响效率的，但是不太严重，原因是它使用的是system.profile来记录，system.profile是一个capped collection(固定集合)，这种collection在操作上有一些限制和特点，但是效率高 mongodb主从集群mongodb支持在多个机器中通过异步复制达到故障转移和实现冗余。多机器中同一时刻只有一台是用于写操作。正是由于这个情况，为mongodb提供了数据一致性的保障。担当primary(主服务器)角色的机器能把读操作分发给slave(从服务器)。 replica sets复制（副本集）mongodb在1.6版本开发了replica set，主要增加了故障自动切换和自动修复成员节点，各个db之间数据完全一致，最为显著的区别在于，副本集没有固定的主节点，它是整个集群选举出的一个主节点，当其不工作时变更其他节点。（简单来说就是当主服务器挂了，那么剩余从服务器会自动选举一个出来做主服务器） 部署replica sets（测试）1、启动两个实例（模拟两个mongodb服务器）2、创建数据文件存储路径 12# mkdir -p /usr/local/mongodb/data/data1/# mkdir -p /usr/local/mongodb/data/data2/ 3、创建日志文件路径 12# mkdir -p /usr/local/mongodb/log/dblogs1# mkdir -p /usr/local/mongodb/log/dblogs2 4、创建key目录 1234567# mkdir -p /usr/local/mongodb/key/# cd /usr/local/mongodb/key/# touch key1# touch key2# echo &quot;123456&quot; &gt; key1# echo &quot;123456&quot; &gt; key2# chmod 600 * 5、启动一个实例 1# /usr/local/mongodb/bin/mongod --replSet rs1 --keyFile=/usr/local/mongodb/key/key1 --port 200001 --dbpath=/usr/local/mongodb/data/data1/ --logpath=/usr/local/mongodb/log/dblogs1 --fork 再启动一个实例 1# /usr/local/mongodb/bin/mongod --replSet rs1 --keyFile=/usr/local/mongodb/key/key2 --port 200002 --dbpath=/usr/local/mongodb/data/data2/ --logpath=/usr/local/mongodb/log/dblogs2 --fork 6、配置及初始化replica set（登录一台机器进行配置） 1# /usr/local/mongodb/bin/mongo --port 200001 进入后，直接配置（直接输入）即可config_rs1={ _id:”rs1”, members:[ {_id:0, host:”localhost:200001”, priority:1}, {_id:1, host:”localhost:200002”, priority:2} ]} 最后初始化配置rs.initiate(config_rs1); 这样就配置好了，端口号为200002的就相当于主服务器(因为优先级priority比较大)，端口号200001就是从服务器，主服务器可以就行增删改查数据，从服务器就只能查询数据 登录从服务器客户端输入命令，这样才有读的权限rs.slaveOk(); 扩展：查看副本集状态命令：rs.status(); 参考mongodb中文社区菜鸟教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb数据库]]></title>
      <url>%2F2017%2F05%2F01%2Fmongodb%2F</url>
      <content type="text"><![CDATA[NoSQL数据库的优缺点优点：简单的扩展、快速的读写、低廉的成本、灵活的数据模型不足：不提供对SQL的支持、支持的特性不够丰富、现有的产品不够成熟 Mongodb特性mongodb的特点是高性能、易部署、易使用，存储数据非常方便，主要的特性有：面向集合存储，易于存储对象类型的数据模式自由支持动态查询支持完全索引，包含内部对象支持复制和故障恢复使用高效的二进制数据存储，包括大型对象（如视频等）自动处理碎片，以支持云计算层次的扩展性文件存储格式为BSON（一种JSON的扩展） mongobd体系结构逻辑结构关系对比关系型数据库：mysql数据库(database)、表(table)、记录(rows)三个层次概念组成非关系型数据库：mongodb数据库(database)、集合(collection)、文档对象(document)三个层次概念组成 mongodb的安装（安装较简单，不用源码编译安装，直接拷贝bin目录到你的安装目录即可）环境：Centos6.51、到mongodb官网下载对应的安装包2、解压压缩包 1# tar zxvf mongodb-linux-x86_64-amazon-3.4.4.tgz 3、拷贝bin目录到指定文件夹(我这里安装到/usr/local/mongodb) 12# cd mongodb-linux-x86_64-amazon-3.4.4/# rsync -a bin /usr/local/mongodb 4、进入到安装目录（/usr/local/mongodb），创建专门放置数据库的目录,记载日志文件 12345# cd /usr/local/mongodb///创建放置数据库的目录# mkdir data//创建记载日志文件# touch dblogs 至此mongodb已经安装完毕 扩展：mongodb开机自启动将mongodb启动项目加入rc.local保证mongodb在服务器开机时启动法1：vim /etc/rc.local加入/usr/local/mongodb/bin/mongod –dbpath=/usr/local/mongodb/data/ –logpath=/usr/local/mongodb/dblogs –fork 法2： 1# echo &quot;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/dblogs --fork&quot; &gt;&gt; /etc/rc.local 启动mongodb1# /usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/dblogs --fork 启动命令常用参数选项说明：–dbpath //指定数据库的目录–auth //用户验证–port //指定数据库的端口，默认是27017–bind_ip //绑定ip–directoryperdb //为每个bd创建一个独立子目录–logpath //指定日志存放目录–logappend //指定日志生成方式(追加/覆盖)–pidfilepath //指定进程文件路径，如果不知道，将不产生进程文件–keyFile //集群模式的关键标识–journal //启用日志–nssize //指定.ns文件的大小，单位MB，默认是16M，最大2GB–maxConns //最大的并发连接数–notablescan //不允许进行表扫描–noprealloc //关闭数据文件的预分配功能–fork //以后台Daemon形式运行服务更多参数选项利用mongod –help进行查看 关闭mongodb1234//法1# pkill mongod//法2# killall mongod 最好用上面两种的一种，如果用kill -9 进程id，会重启不了mongodb，需要到data目录下把锁文件(mongod.lock)删除掉，具体操作如下： 12# cd /usr/local/mongodb/data# rm -rf mongod.lock //把锁文件删除掉 用户授权（即登录需要用户名和密码）1、每个mongodb实例中的数据库都有许多用户，如果启用了安全性认证后，只有数据库认证的用户才可以进行读写操作。mongodb默认的启动是不验证用户名和密码的，启动mongodb后，可以直接用mongo连接上来，对所有的库具有root权限。所以启动的时候指定参数，可以阻止客户端的访问和连接，只需在启动服务时指定 –auth参数即可 1# /usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --auth --logpath=/usr/local/mongodb/dblogs --fork 2、现在还是可以通过/usr/local/mongodb/bin/mongo可以直接进入客户端操作的因为现在没有管理员帐号，mongodb分两种管理员，一种为超级管理员，一种为数据库管理员(即只对自己的数据库有权限) 2.1、先通过/usr/local/mongodb/bin/mongo进入到客户端创建帐号 2.2、创建超级管理员（一定要进入admin数据库创建才行）//先进入admin数据库use admin;//创建帐号root,密码为123db.addUser(“root”, “123”); 2.3、创建数据库管理员比如我需要为test数据库创建管理员，那我需要进入到test数据库先use test;db.addUser(“test”, “123”); 2.4测试登录创建好帐号后，退出客户端，再重新登录进入客户端exit;/usr/local/mongodb/bin/mongo -uroot -p123 localhost:27017/admin //超级管理员登录进入admin数据库 2.5总结超级管理员需要进入admin数据库进行创建，数据库管理员需要进入到对应的数据库进行创建。 参考mongodb中文社区菜鸟教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql-主从复制]]></title>
      <url>%2F2017%2F03%2F20%2Fmysql-master-slave%2F</url>
      <content type="text"><![CDATA[mysql主从复制和慢查询日志说明 MySQL主从复制MySQL grant用户授权（先登录主服务器数据库进行用户授权）在主服务器设置授权用户（授权所有权限关于所有数据库中所有表，给user这个用户从主机为192.168.10.2登录，密码为123456）1234567//方法1：mysql&gt; grant all on *.* to user@192.168.10.2 identified by &apos;123456&apos;;//方法2：mysql&gt; grant replication slave on *.* to user@192.168.10.2 identified by &apos;123456&apos;;//查看用户授权表（即mysql数据库中的user表）mysql&gt; select user,host,password from mysql.user; 修改主数据库服务器的配置文件my.cnf，开启big-log日志，并设置server-id的值log-bin=mysql-binserver-id=1 备份主服务器的数据库1234//清除bin-log日志mysql&gt; reset master;//备份数据库mysql&gt; /usr/local/mysql/bin/mysqldump -uroot -p123456 test -l -F &gt; /tmp/test.sql 同步从服务器上的数据12//先从主服务器复制一份test.sql到从服务器(192.168.10.2)下的tmp目录[root@localhost]# scp /tmp/test.sql 192.168.10.2:/tmp/ 123456//登录从服务器数据库mysql&gt; /usr/local/mysql/bin/mysql -uroot -p123456 test//清空所有的big-log日志mysql&gt; reset master;//进行导入同步数据mysql&gt; /usr/local/mysql/bin/mysql -uroot -p123456 test &lt; /tmp/test.sql 配置从服务器的配置文件my.cnflog-bin=mysql-binserver-id=2master-host=192.168.10.1master-user=usermaster-password=123456master-port=3306 重启从服务器mysql(先关闭mysql，再重启mysql)123456789//关闭方法1pkill mysqld//关闭方法2ps -aux | grep mysql //先查看进程pidkill -15 pid //正常关闭//重启mysql/usr/local/mysql/bin/mysqld_safe --user=mysql &amp; 查看从服务器是否已经同步了（查看相应的主从复制进程列表）方法1：1mysql&gt; show slave status\G 如下图所示：Slave_IO_Running:Yes //此进程负责读取主服务器上的big-log日志，并且写入到从服务器上的big-log日志Slave_SQL_Running:Yes //此进程负责读取并且执行big-log日志表示已经同步了（注意：以上两个都为Yes则表示成功，否则失败，错误原因可以从”last_error”字段的值中看到） 方法2：1mysql&gt; show processlist\G 如下图所示：state:waiting for master to send event //表示连接主数据库为成功，而且成功获取big-logstate:has read all ready log;waiting for the slave i/o thread to update it //表示成功执行big-log日志，正在等待着再次连接主数据库并更新获取big-log日志表示已经同步了 扩展从数据库常用命令：12345mysql&gt; start slave; //启动复制进程mysql&gt; stop slave; //停止复制进程mysql&gt; show slave status; //查看数据库状态mysql&gt; change master to //动态改变服务器的配置mysql&gt; show processlist //查看数据库运行进程 从数据库无法同步：Show slave status显示slave_sql_running为No,seconds_behind_master为null原因：1、程序可能在slave上进行了写操作2、也可能是slave机器(从服务器)重启后，事务回滚造成的 解决方法1：123mysql&gt; slave stop;mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;mysql&gt; slave start; 解决方法2：停止从服务器复制进程1mysql&gt; slave stop; 查看主服务器当前的bin-log日志名和偏移量1mysql&gt; show master status; //下一步需要用到日志名称和偏移量 如图所示 最后到slave(从)服务器上执行手动同步123456789101112mysql&gt; change master tomaster_host=&quot;192.168.10.1&quot;,master_user=&quot;user&quot;,master_password=&quot;123456&quot;,master_port=3306,master_log_file=&quot;mysql-bin.000003&quot;, //对应上一步的日志名称master_log_pos=98; //对应上一步的偏移量//启动slave(复制进程)mysql&gt; slave start;//最后再查看数据库状态mysql&gt; show slave status\G MYSQL bin-log日志开启MYSQL bin-log日志vim /etc/my.cnf[mysqld]….log-bin=mysql-bin bin-log日志相关mysql指令可以查看是否开启bin-log日志1mysql&gt; show variables like &quot;%bin%&quot;; 生成一个最新的bin-log日志1mysql&gt; flush logs; 查看big-log日志1mysql&gt; show binary logs; 查看最后一个big-log日志1mysql&gt; show master status; 清空所有的big-log日志1mysql&gt; reset master; 使用mysqlbiglog来查看big-log日志（打开mysql-bin.000002日志）1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults mysql-bin.000002 如果不加参数–no-defaults会报错，报错内容是说字符集有问题 mysql备份和bin-log日志结合使用例子： 1、对test数据库进行备份数据，备份完成的同时生成一个新的log-bin日志文件：1[root@localhost]# /usr/local/mysql/bin/mysqldump -uroot -p123456 test -l -F &gt; /tmp/test.sql 参数说明：-l为读锁(备份期间所有人都不能进行写的操作，但是可以进行读的操作)、-F(即相当于执行了flush logs指令),可以重新生成新的日志文件，其中包括log-bin日志 2、在备份完成后又添加了一些数据123mysql&gt; insert into t1 values(3);mysql&gt; insert into t1 values(4);mysql&gt; insert into t1 values(5); 3、此时突然数据库损坏或者人为删除模拟人为删除表1mysql&gt; drop table t1; 如何恢复数据？步骤一，先用已经备份的t1.sql来恢复数据12[root@localhost]# /usr/local/mysql/bin/mysql -uroot -p123456 test -f &lt; /tmp/test.sql参数-f(可选参数)表示当遇到错误时，可以skip过去，继续执行下面的语句 但是自从上次备份后添加或者修改的数据会丢失，怎么办？只能用big-log来恢复 先查看最后生成的big-log日志1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults mysql-bin.000005 | more 截图如下： 找到对应的sql语句对应的end_log_post id开始用big-log来恢复备份后添加或者修改的数据1[root@localhost]# /usr/local/mysql/bin/mysqlbinlog --no-defaults --stop-position='666' mysql-bin.000005 | /usr/local/mysql/bin/mysql -uroot -p123456 test mysqlbinlog可选参数说明：–start-position=’20’–stop-position=’111’–start-date=’2017-01-18 00:00:00’–stop-date=’2017-01-18 23:59:59’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql-分区技术]]></title>
      <url>%2F2017%2F03%2F16%2Fmysql-partition%2F</url>
      <content type="text"><![CDATA[mysql-分区技术 MYSQL分区技术MYSQL的分区技术与水平分表有点类似，但是它是在逻辑层进行的水平分表，对于应用程序而言它还是一张表。MYSQL5.1有5种分区类型：RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区LIST分区：类似于RANGE分区，区别在于LIST分区是基于列值分配一个离散集合中的某个值来进行选择HASH分区：。。。KEY分区：。。。 例子1：假定你创建了一个如下的表，该表保存有20家音像店的职员记录，这20家音像店的编号从1到20.如果你想将其分成4个小分区，那么你可以采用RANGE分区，创建的数据库表如下：123456789101112131415mysql&gt; CREATE TABLE employees( id INT NOT NULL, fname VARCHAR(30), iname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT NOT NULL, store_id INT NOT NULL)engine=myisam default charset=utf8PARTITION BY RANGE(store_id)( PARTITION p0 VALUES LESS THAN(6), PARTITION p1 VALUES LESS THAN(11), PARTITION p2 VALUES LESS THAN(16), PARTITION p3 VALUES LESS THAN(21)); 例子2：假定你创建了一个如下的表，该表保存有20家音像店的职员记录，这20家音像店的编号从1到20。如果你想把不同时期离职的员工进行分别存储，那么你可以将日期字段separated(即离职时间)作为一个key，创建的数据库表如下：123456789101112131415mysql&gt; CREATE TABLE employees1( id INT NOT NULL, fname VARCHAR(30), iname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT NOT NULL, store_id INT NOT NULL)PARTITION BY RANGE(YEAR(separated))( PARTITION p0 VALUES LESS THAN(1991), PARTITION p1 VALUES LESS THAN(1996), PARTITION p2 VALUES LESS THAN(2001), PARTITION p3 VALUES LESS THAN MAXVALUE); 说明：YEAR()是mysql的一个日期函数，将日期类型的字段转换为整数类型，从而就可以作为RANGE分区的key。 条件(range、list)分区算法管理增加分区： alter table 表名 add partition( partition 分区名 values less than[in] (常量[列表]), partition 分区名 values less than[in] (常量[列表]), …. )减少分区： alter table 表名 drop partition 分区名称; 减少分区，会丢失对应分区的数据。 例如：1234mysql&gt; alter table employees1 add partition( partition p4 values less than (2008), partition p4 values less than (2009)); innodb表数据结构对于innodb表的数据结构，首先要解决两个概念性的问题：共享表空间以及独占表空间。共享表空间以及独占表空间都是针对数据的存储方式而言的。共享表空间：某一个数据库的所有的表数据、索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下，默认的文件名为：ibdata1，初始化大小为10M。独立表空间：每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个。frm表描述文件，还有一个.ibd文件。其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下他的存储位置也是在表的位置之中 查看innodb表空间设置12//为on表示是独立表空间，off表示共享表空间mysql&gt; show variables like &apos;innodb_file_per_table&apos;; 如何修改innodb表为独立表空间配置mysql的配置文件my.cnf…innodb_data_home_dir=”C:\mysql\data\” //默认存在的，只需把前面井号去掉即可innodb_log_group_home_dir=”C:\mysql\data\” //默认存在的，只需把前面井号去掉即可innodb_data_file_path=ibdata1:10M:autoextend //默认存在的，只需把前面井号去掉即可innodb_file_per_table=1 参数说明：这些设置表示配置一个可扩展大小的尺寸为10MB的单独文件，名为ibdata1,没有给出文件的位置，所以默认的是在mysql的数据目录内。innodb_data_home_dir //代表为数据库文件所存放的目录innodb_log_group_home_dir //为日志存放目录innodb_file_per_table //是否使用共享以及独立表空间来以上的几个参数必须在一起加入 把共享表空间的表转移到独立表空间步骤：1、使用mysqldump导出所有数据库表数据2、停止mysql服务，修改参数（修改为独立表空间），并删除原先innodb共享表相关文件3、重启mysql服务4、重新导入数据 说明：1、只有把innodb设置成独立表空间后，才能创建成功innodb表引擎的表分区2、mysql5.6之后版本默认配置是独立表空间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql-SQL语句技巧和优化]]></title>
      <url>%2F2017%2F03%2F13%2Fmysql-optimize%2F</url>
      <content type="text"><![CDATA[SQL语句技巧和优化 mysql SQL语句技巧和优化mysql5.5及之后版本默认存储引擎是innodb 巧用RAND()提取随机行rand()是获取一个0-1之间的随机数1select * from st_vonfly order by rand(); 随机抽取3条数据样本1select * from st_vonfly order by rand() limit 3; 优化group by语句有的sql语句在执行的时候，本身默认会有排序效果但是有的时候我们的业务不需要排序效果，就可以进行强制限制，进而“节省默认排序”的资源。 如果查询包含group by但用户想要避免排序结果的损耗，则可以使用order by null来禁止排序： 优化嵌套查询表1如图：CREATE TABLE tp_user ( id int(10) unsigned NOT NULL AUTO_INCREMENT, name varchar(16) NOT NULL, parents_id int(10) NOT NULL, PRIMARY KEY (id)) ENGINE=MyISAM DEFAULT CHARSET=utf8表2如图：CREATE TABLE tp_parents ( id int(10) unsigned NOT NULL AUTO_INCREMENT, parent_name varchar(16) NOT NULL, PRIMARY KEY (id)) ENGINE=MyISAM DEFAULT CHARSET=utf8 下面是采用嵌套查询的效果（可以使用更有效的连接查询(JOIN)替代） mysql&gt; desc select from tp_parents where id in(select parents_id from tp_user)\G** 1. row * id: 1 select_type: PRIMARY table: tp_parents type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 3 Extra: Using where* 2. row * id: 2 select_type: DEPENDENT SUBQUERY table: tp_user type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 4 Extra: Using where2 rows in set (0.06 sec) 数据库优化优化表的类型通过拆分提高表的访问效率使用中间表提高统计查询速度 MYSQL服务器优化四种字符集问题(统一设置为utf8)1mysql&gt; \s 如何设置？vim /etc/my.cnf[client] #password=your_passwordport=3306socket=/tmp/mysql.sockdefault-character-set=utf8 //控制的是客户端字符集和连接字符集 [mysqld]…….myisam_sort_buffer_size=8Mcharacter-set-server=utf8 //控制服务器字符集和数据库字符集collation-server=utf8_general_ci //校验字符集，主要针对的排序 查看中文字符集以及对应的校验字符集1mysql&gt; show character set; 如图所示： bin log日志问题slow log慢查询日志问题可以查看是否开启慢查询日志1mysql&gt; show variables like &quot;%slow%&quot;; 设置的慢查询时间1mysql&gt; show variables like &quot;%long%&quot;; 开启慢查询日志和设置慢查询时间：vim /etc/my.cnf[mysqld]…….log_slow_queries=slow.loglong_query_time=5 socket问题mysql socket无法登录1.有时登录mysql时提示不能用socket登录，此时可以换成tcp方式去登录，但是只有测试时可以这样用，必须要在php去用之前把这个事情解决了 1# mysql -uroot -p123456 --protocol tcp -hlocalhost 这样就可以登录，就不用mysql.socket来登录。把mysql重新启动就会自动生成socket文件 root密码丢失root密码丢失破解步骤1.service mysqld stop //把mysql关闭2.mysqld_safe –skip-grant-tables –user=mysql &amp; //跳过授权表mysql.user和mysql.db来重启mysql3.mysql -uroot; //登录进mysql4.1mysql&gt; update mysql.user set password=password(&quot;123456&quot;) where user=&quot;root&quot; and host=&quot;localhost&quot;; SQL语句的优化步骤一、通过慢查询日志查看效率低的sql语句二、通过explain或者desc解析sql语句(查看是否需要做索引)12explain select * from table where id = 8\Gdesc select * from table where id = 8\G 每一列的简单解释id:1select_type:SIMPLE //表示select的类型，常见的取值有SIMPLE(简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(子查询中的第一个SELECT)等table:stu //输出结果集的表type:range //表示表的连接类型，性能由好到查：system(表仅一行)、const(只一行匹配)、eq_ref(对于前面的每一行使用主键和唯一)、ref(同eq_ref，但没有使用主键和唯一索引)、ref_or_null(同前面，对null查询)、index_merge(索引合并优化)、unique_subquery(主键子查询)、index_subquery(非主键子查询)、range(表单中的范围查询)、index(都通过查询索引来得到数据)、all(通过全表扫描得到的数据)possible_keys:name,ind_stu_name //表查询时可能使用的索引key:name //表示实际使用的索引key_len:50 //索引字段的长度ref:NULLrows:8 //扫描行的数量Extra:Using where;Using index //执行情况的说明和描述 总结：where 和 order by后边的条件字段都可以适当设置索引、分组字段也可以添加索引，避免产生临时表 对表的优化和检测检查一个或多个表是否有错误语法如下：1mysql&gt; CHECK TABLE tb1_name[,tb1_name]...[option]... option=&#123;QUICK|FAST|MEDIUM|EXTENDED|CHANGED&#125; 例子（检查a1表是否有错误）：1mysql&gt; check table a1; 对损坏或错误的表进行修复语法如下：1mysql&gt; repair TABLE tb1_name[,tb1_name]...[option]... 例子（修复a1表）：1mysql&gt; repair table a1; 定期优化表（找访问较少的时间进行优化，防止影响业务）如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表进行了很多的改动，则需要做定期优化。这个命令(optimize)可以将表中的空间碎片进行合并，但是此命令只对myisam、BDB和innobd表起作用。 语法：1mysql&gt; OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tb1_name [,tb1_name] 例子(对a1表进行优化)：1mysql&gt; optimize table a1; 字段类型选择原则：当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。 信息最好存储为整型的(mysql运行速度快，运算速度快)时间信息可以存储为整型的(时间戳)，用int类型select from_unixstamp(时间戳) from 表名 set集合类型 多选：set(‘篮球’,’足球’,’棒球’,’乒乓球’);enum枚举类型 单选： enum(‘男’,’女’,’保密’);推荐使用set和enum类型，内部会通过整型信息参数具体计算、运行。 ip地址也可以变为整型信息进行存储(mysql内部有算法，把ip变为数字)：mysql： inet_aton(ip) inet_ntoa(数字)php: ip2long(ip) long2ip(数字) 尽量少的占据存储空间tinyint : 0~255 1字节smallint : 0~ 65535 2字节mediumint : 0~1千6百多万 3字节int : 0~40多亿 4字节 数据的整合最好固定长度char :0~255个字符varchar : 0~65535 字节 看表编码，如果是utf8存2万多汉字 gbk存3万多汉字 char(长度)固定长度，运行速度快长度：255字符限制varchar(长度)长度不固定，内容比较少要进行部位操作，该类型要保留1-2个字节保存当前数据的长度长度：65535字节限制 存储汉字，例如字符集utf8的(每个汉字占据3个字节)，最多可以存储65535/3-2字节 例如字符集gbk的(每个汉字占据2个字节)，最多可以存储65535/2-2字节 如存储手机号码：char(11) ，可以选取固定长度的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql简单操作]]></title>
      <url>%2F2017%2F03%2F08%2Fmysql-commands%2F</url>
      <content type="text"><![CDATA[常用的一些mysql操作（mysql高性能优化、mysql深入浅出） mysql具体语法帮助123456mysql&gt; ? contents //查看所有帮助大纲，然后通过帮助大纲再用?继续往下查询具体语法mysql&gt; ? index //查看索引具体操作帮助信息mysql&gt; ? view //查看视图具体操作帮助信息mysql&gt; ? create view //创建视图具体操作帮助信息mysql&gt; ? reg% //如果记不住全称，可以使用%来代替 结果进行行列颠倒（\G）12mysql&gt; show plugins;mysql&gt; show plugins\G mysql表复制（包括复制表结构和表数据）12mysql&gt; create table vf_a2 like vf_a1; //先复制表结构mysql&gt; insert into vf_a2 select * from vf_a1; //复制表数据。说明：表vf_a1和表vf_a2字段完全一样的前提下用*，否则要复制某些字段要具体写字段 表名修改12//把表名为t2修改为t1mysql&gt; rename table t2 to t1; 索引的创建、删除、查看方法一： create index（创建索引）、drop index（删除索引）12345mysql&gt; create index in_name on vf_a1(name); //为表vf_a1的name字段创建普通索引mysql&gt; create unique index un_name on vf_a1(name); //为表vf_a1的name字段创建唯一索引mysql&gt; drop index in_name on vf_a1; //删除表vf_a1名称为in_name的索引 方法二（常用以及全面的方法，可以创建普通索引、唯一(unique)索引和主键(primary key)索引）：1234567891011121314151617mysql&gt; alter table vf_a1 add index in_name(name); //为表vf_a1的name字段创建普通索引mysql&gt; alter table vf_a1 add unique in_name(name); //为表vf_a1的name字段创建唯一索引mysql&gt; alter table vf_a1 drop index in_name; //删除表vf_a1名称为in_name的索引//删除主键索引（先删除主键字段的自增，然后再删除主键索引）mysql&gt; id int unsigned not null auto_increment //原来字段mysql&gt; alter table vf_a1 modify id int unsigned not null; //修改字段（不写auto_increment就是把auto_increment(自增)删除了）mysql&gt; alter table vf_a1 drop primary key; //再删除主键索引//增加主键索引(先添加主键索引，再修改主键字段为自增)mysql&gt; alter table vf_a1 add primary key(id);mysql&gt; id int unsigned not null; //原来字段mysql&gt; alter table vf_a1 modify id int unsigned not null auto_increment; //修改主键字段为自增 查看索引1mysql&gt; show index from vf_a1; //查看表vf_a1下的索引 mysql视图（中间表，把满足条件的记录生成一张中间表，就可以直接对这张表进行增删改查，提高性能）创建视图1mysql&gt; create view v_a1 as select * from a1 where id&gt;8; 查看视图（即查看表）1mysql&gt; show tables; 删除视图1mysql&gt; drop view v_a1; //删除名称为v_a1的视图 mysql存储需求：向表a1（有主键id和name两个字段）插入一百条数据，字段name的值依次为user1、user2、user3…..user100 先修改定界符，因为mysql存储很多语句都是以分号结束的1mysql&gt; \d // //把语句定界符分号修改为// 再创建存储12345678mysql&gt; create procedure p1() -&gt; begin -&gt; set @i=1; -&gt; while @i&lt;=100 do -&gt; insert into a1(name) values(concat(&quot;user&quot;, @i)); -&gt; set @i=@i+1; -&gt; end while; -&gt; end// 最后执行刚刚创建的存储p1123mysql&gt; call p1;mysql&gt; select * from a1; //查看数据是否创建成功 查看mysql存储123mysql&gt; show procedure status; //查看存储状态mysql&gt; show create procedure p1; //查看存储p1的具体信息 mysql事务处理(innodb表引擎才支持)12//关闭自动提交功能mysql&gt; set autocommit=0; 12//从表a1中删除了一条记录mysql&gt; delete from a1 where id=11; 12//此时做一个p1还原点mysql&gt; savepoint p1; 12//再次从表a1中删除了一条记录mysql&gt; delete from a1 where id=12; 12//再次做一个p2还原点mysql&gt; savepoint p2; 12//此时恢复到p1还原点，当然后面的p2这些还原点自动会失效mysql&gt; rollback to p1; 12//如果退回到最原始的还原点mysql&gt; rollback; 清空表(清空内容以及auto_increment恢复成1开始)1mysql&gt; truncate table tablename; mysql变量使用（需要查些资料多学习下,如mysql手册）1、需求：查询排名create table vo_students( id int unsigned not null auto_increment, name varchar(30) not null default ‘’ comment ‘名字’, score smallint not null default 0 comment ‘分数’, primary key (id))engine myisam default charset utf8;insert into vo_students(name, score) values (‘zhang’, 100),(‘li’, 89),(‘sun’, 57),(‘zhao’, 100),(‘zhou’, 89),(‘qian’, 92); 具体方法：set @pres:=0,@currs:=0,@rank:=0;select name,(@currs:=score) as score, @rank:=if(@currs&lt;&gt;@pres,@rank:=@rank+1,@rank) as rank,@pres:=score as prev from vo_students order by score desc; mysql内置函数——————————————————————- 字符串函数： CONCAT(string2 [,….]) //连接字符串1select concat(&quot;hello &quot;, &quot;world&quot;); LCASE(sting2) //转换成小写UCASE(sting2) //转换成大写 LENGTH(string2) //string2的长度1select length(&quot;vonfly&quot;); LTRIM(string2) //去除左边空格RTRIM(string2) //去除右边空格 REPEAT(string2,count) //重复count次1select repeat(&quot;vonfly&quot;, 6); REPLACE(string2, search_str, replace_str) //在string2中用replace_str替换search_str1select replace(&quot;vonfly is my web&quot;, &quot;my&quot;, &quot;your&quot;); SUBSTR(string2, position [,length]) //从string2的position开始，取length个字符1select substr(&quot;vonfly is my web&quot;, 1, 5); SPACE(count) //生成count个空格 日期函数CURDATE() //返回当前日期CURTIME() //返回当前时间NOW() //返回当前的日期时间UNLX_TIMESTAMP(date) //返回当前date的UNIX时间戳FROM_UNIXTIME() //返回UNLX时间戳的日期值YEAR(date) //返回日期date的年份DATEDIFF(expr1,expr2) //返回起始时间expr1和结束时间expr2的天数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[收集、总结的一些PHP理论知识（对于面试有帮助）]]></title>
      <url>%2F2017%2F02%2F28%2Fphp-knowledge%2F</url>
      <content type="text"><![CDATA[本页面主要用于编写一些理论知识，从网上找的或者自己总结的都会有。主要用于自己学习。如发现本网站载有侵犯您著作权的侵权信息，可联系我删除(●’◡’●) 用最少的代码写一个求3值最大值的函数123function($a,$b,$c)&#123; return $a &gt; $b ? ($a &gt; $c ? $a : $c) : ($b &gt; $c ? $b : $c);&#125; 用PHP打印出前一天的时间，打印格式是2007年5月10日22:21:211echo date('Y-m-d H:i:s', strtotime('-1 day')); 输出正在浏览当前页面用户的IP地址1echo $_SERVER["REMOTE_ADDR"]; 查询（query）的字符串URL中第一个问号 ? 之后的内容（比如http://localhost/text.php?id=1&amp;bi=2，查询出 id=1&amp;bi=2 ）1echo $_SERVER["QUERY_STRING"]; 当前运行脚本所在的文档根目录1echo $_SERVER["DOCUMENT_ROOT"]; 写一个函数，能够遍历一个文件夹下的所有文件和子文件夹123456789101112131415161718192021222324252627function my_scandir($dir)&#123; $files=array(); if(is_dir($dir)) &#123; if($handle=opendir($dir)) &#123; while(($file=readdir($handle))!==false) &#123; if($file!="." &amp;&amp; $file!="..") &#123; if(is_dir($dir."/".$file)) &#123; $files[$file]=my_scandir($dir."/".$file); &#125; else &#123; $files[]=$dir."/".$file; &#125; &#125; &#125; closedir($handle); return $files; &#125; &#125;&#125;var_dump(my_scandir("F:ali")); 请用正则表达式（Regular Expression）验证电子邮件的格式是否正确。123456789$email = '1185236@163.com';if( !preg_match('/^[\w.]+@([\w.]+)\.[a-z]&#123;2,6&#125;$/i', $email) )&#123; echo "电子邮件格式不正确！";&#125;else&#123; echo "电子邮件格式正确！";&#125; 用PHP写出显示客户端IP与服务器IP的代码12echo $_SERVER["REMOTE_ADDR"]; //客户端IPecho gethostbyname("www.baidu.com"); //服务器IP 如何修改SESSION的生存时间方法1：将php.ini中的session.gc_maxlifetime设置为9999重启apache 方法2：在当前项目中修改123$expire = 3600 * 3;ini_set('session.gc_maxlifetime', $expire);ini_set('session.cookie_lifetime', $expire); 有一个网页地址, 比如百度主页: http://www.baidu.com/,如何得到它的内容?方法1：1234$readcontents = fopen("http://www.baidu.com/", "rb");$contents = stream_get_contents($readcontents);fclose($readcontents);echo $contents; 方法2：12$readcontents = file_get_contents("http://www.baidu.com/");echo $readcontents; 请说明php中传值与传引用的区别。什么时候传值什么时候传引用?按值传递：函数范围内对值的任何改变在函数外部都会被忽略 按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改 优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。 按引用传递则不需要复制值，对于性能提高很有好处。 写一个函数，尽可能高效的，从一个标准 url 里取出文件的扩展名例如: http://www.sina.com.cn/abc/de/fg.php?id=1 需要取出 php 或 .php方法1：1234567function getExt($url)&#123; $arr = parse_url($url); $file = basename($arr['path']); $ext = explode(".", $file); return $ext[1];&#125;echo getExt('http://www.sina.com.cn/abc/de/fg.php?id=1'); 方法2：123456789101112function getExt($url) &#123; $url = basename($url); $pos1 = strpos($url, "."); $pos2 = strpos($url, "?"); $length = $pos2 - $pos1 - 1; if(strstr($url, "?"))&#123; return substr($url, $pos1 + 1, $length); &#125; else &#123; return substr($url, $pos1); &#125;&#125;echo getExt('http://www.sina.com.cn/abc/de/fg.php?id=1'); 使用五种以上方式获取一个文件的扩展名要求：dir/upload.image.jpg，找出 .jpg 或者 jpg ，必须使用PHP自带的处理函数进行处理，方法不能明显重复，可以封装成函数，比如 get_ext1($file_name), get_ext2($file_name) 12345$file_name = 'dir/upload.image.jpg';function get_ext1($file_name)&#123; return strrchr($file_name, '.');&#125;echo get_ext1($file_name); 12345$file_name = 'dir/upload.image.jpg';function get_ext2($file_name)&#123; return substr( $file_name, strrpos($file_name, '.') );&#125;echo get_ext2($file_name); 1234567$file_name = 'dir/upload/image.jpg';function get_ext3($file_name)&#123; $stack = explode('.', $file_name); $fruit = array_pop($stack); return $fruit;&#125;echo get_ext3($file_name); 123456$file_name = 'dir/upload/image.jpg';function get_ext4($file_name)&#123; $p = pathinfo($file_name); return $p['extension'];&#125;echo get_ext4($file_name); 1234567$file_name = 'dir/upload/image.jpg';function get_ext5($file_name)&#123;return strrev(substr(strrev($file_name), 0, strpos(strrev($file_name), '.')));&#125;echo get_ext5($file_name); 输出以下值1234567891011121314$str1 = null;$str2 = false;echo $str1==$str2 ? '相等' : '不相等';//输出相等$str3 = '';$str4 = 0;echo $str3==$str4 ? '相等' : '不相等';//输出相等$str5 = 0;$str6 = '0';echo $str5===$str6 ? '相等' : '不相等';//输出不相等 MySQL数据库中的字段类型varchar和char的主要区别是什么?那种字段的查找效率要高，为什么?varchar是变长，节省存储空间，char是固定长度。查找效率要char型快，因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些 写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）MyISAM、InnoDB、BDB（Berkeley DB）、Merge、Memory（Heap）、Example、Federated、Archive、CSV、Blackhole、MaxDB 等等十几个引擎 求两个日期的差数，例如2007-2-5 ~ 2007-3-6 的日期差数1234567function get_days($date1, $date2)&#123; $time1 = strtotime($date1); $time2 = strtotime($date2); return abs($time2-$time1)/86400;&#125;echo get_days('2007-2-5', '2007-2-6'); 请写一个函数，实现以下功能：字符串”open_door” 转换成 “OpenDoor”、”make_by_id” 转换成 “MakeById”方法一：1234567function str_explode($str)&#123; $str_arr=explode("_",$str); $str_implode=implode(" ", $str_arr); $str_implode=implode("", explode(" ",ucwords($str_implode))); return $str_implode;&#125;echo str_explode('open_door'); 方法二：123456$str = 'open_door';$expStr = explode("_", $str);for($i = 0; $i &lt; count($expStr); $i++)&#123; echo ucwords($expStr[$i]);&#125; 方法三：1echo str_replace(' ', '', ucwords( str_replace('_', ' ', 'open_door') ) ); echo count(“abc”); 输出什么?答案：1说明：count — 计算数组中的单元数目或对象中的属性个数int count ( mixed$var [, int $mode ] ), 如果 var 不是数组类型或者实现了 Countable 接口的对象，将返回1，有一个例外，如果 var 是 NULL 则结果是 0。 对于对象，如果安装了 SPL，可以通过实现 Countable 接口来调用 count()。该接口只有一个方法 count()，此方法返回 count() 函数的返回值。 有一个一维数组，里面存储整形数据，请写一个函数，将他们按从大到小的顺序排列。要求执行效率高。并说明如何改善执行效率。（该函数必须自己实现，不能使用php函数）1234567891011121314151617181920212223242526function BubbleSort(&amp;$arr)&#123; $cnt = count($arr); $flag = 1; for($i = 0; $i &lt; $cnt; $i++) &#123; if($flag == 0) &#123; return; &#125; $flag = 0; for($j = 0;$j &lt; $cnt-$i-1; $j++) &#123; if($arr[$j] &gt; $arr[$j+1]) &#123; $tmp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $tmp; $flag = 1; &#125; &#125; &#125;&#125;$test=array(1,3,6,8,2,7);BubbleSort($test);var_dump($test); 请举例说明在你的开发过程中用什么方法来加快页面的加载速度答：要用到服务器资源时才打开，及时关闭服务器资源，数据库添加索引，页面可生成静态，图片等大文件单独服务器。使用代码优化工具 HTTP协议中GET、POST和HEAD的区别?HEAD： 只请求页面的首部。 GET： 请求指定的页面信息，并返回实体主体。 POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。 （1）HTTP 定义了与服务器交互的不同方法，最基本的方法是 GET 和 POST。事实上 GET 适用于多数请求，而保留 POST 仅用于更新站点。 （2）在FORM提交的时候，如果不指定Method，则默认为GET请 求，Form中提交的数据将会附加在url之后，以?分开与url分开。字母数字字符原样发送，但空格转换为“+“号，其它符号转换为%XX,其中XX为 该符号以16进制表示的ASCII（或ISO Latin-1）值。GET请求请提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中； GET方式提交的数据最多只能有1024字节，而POST则没有此限制。 （3）GET 这个是浏览器用语向服务器请求最常用的方法。POST这个方法也是用来传送数据的，但是与GET不同的是，使用POST的时候，数据不是附在URI后面传递的，而是要做为独立的行来传递，此时还必须要发送一个Content_length标题，以标明数据长度，随后一个空白行，然后就是实际传送的数据。网页的表单通常是用POST来传送的。 Cookie和session的区别，禁止了cookie后session能正常使用吗?session的缺点是什么?session在服务器端是存在哪里的?是共有的还是私有的?答：COOKIE保存在客户端，用户通过手段可以进行修改，不安全，单个cookie允许的最大值是3k。 而SESSION保存在服务器端，相对比较安全，大小没有限制。 Session依赖于cookie进行传递。 禁用了cookie之后session不能正常使用。 Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。 Session保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。 Session文件是公有的。 写几个魔术方法并说明作用?__call()当调用不存在的方法时会自动调用的方法 __autoload()在实例化一个尚未被定义的类是会自动调用次方法来加载类文件 __set()当给未定义的变量赋值时会自动调用的方法 __get()当获取未定义变量的值时会自动调用的方法 __construct()构造方法，实例化类时自动调用的方法 __destroy()销毁对象时自动调用的方法 __unset()当对一个未定义变量调用unset()时自动调用的方法 __isset()当对一个未定义变量调用isset()方法时自动调用的方法 __clone()克隆一个对象 __tostring()当输出一个对象时自动调用的方法 数组中下标最好是什么类型的，为什么?数组的下标最好是数字类型的，数字类型的处理速度快 ++i和i++哪一个效率高，为什么?++i效率比i++的效率更高，因为++i少了一个返回i的过程。 echo()、print()、print_r()的区别?echo 是php语法，可以输出多个变量，不能输出数组。 Print()是php中的函数，只能输出简单的变量。 Print_r()是php中的函数，可以输出变量也可以输出数组。 框架中什么是单一入口和多入口，单一入口的优缺点?1、多入口就是通过访问不同的文件来完成用户请求。单一入口只web程序所有的请求都指向一个脚本文件的。2、单一入口更容易控制权限，方便对http请求可以进行安全性检查。缺点：URL看起来不那么美观，特别是对搜索引擎来说不友好。 提示类型200、404、502是什么意思。200是请求成功，404是文件未找到，502是服务器内部错误。 你对Memcach的理解，优点有哪些?Memcache是一种缓存技术，在一定的时间内将动态网页经过解析之后保存到文件，下次访问时动态网页就直接调用这个文件，而不必在重新访问数据库。使用memcache做缓存的好处是：提高网站的访问速度，减轻高并发时服务器的压力。 Memcache的优点：稳定、配置简单、多机分布式存储、速度快。 对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:a) 索引的目的是什么? b) 索引对数据库系统的负面影响是什么? c) 为数据表建立索引的原则有哪些? d) 什么情况下不宜建立索引? 答：索引的目的： 1、快速访问数据表中的特定信息，提高检索速度 2、创建唯一性索引，保证数据库表中每一行数据的唯一性 3、加速表和表之间的连接 4、使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据的维护速度。 建立索引的原则： 1、在最频繁使用的、用以缩小查询范围的字段上建立索引 2、在平频繁使用的、需要排序的字段上建立索引 什么情况下不宜建立索引： 1、对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引 2、对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)等。 web应用中,数据库的读取频率远高于写入频率, 如何优化MySQL而应对此种情景 ?使用memcache缓存技术，将动态数据缓存到文件，访问动态页面时直接调用缓存文件，而不必重新访问数据库，这样就减少了查询数据库的次数。 如果网站的访问量很大，可以把数据库读写服务器分开，使用多态服务器去处理数据库查询，使用较少的服务器去处理数据库的写入和修改。 include与require的区别?Php在遇到include时就重新解释一次，如果一个页面中出现10次include，php就重新解释10次，而php遇到require时只解释一次，即使页面中出现多次require，php也直解释一次。 使用require包含文件时，被包含的文件当成了当前文件的一个组成部分，如果被包含的文件中有语法错误或者文件不存在，程序就提示错误信息，并结束执行。 使用include包含文件时，相当于指定了文件的路径，被包含的文件中有语法错误或者文件不存在时，页面只是给出警告信息，不响应程序本身的执行。 PHP字符串中单引号与双引号的区别?单引号不能解释变量，而双引号可以解释变量。单引号不能转义字符，在双引号中可以转义字符。 php中,模板引擎的目的是什么? 你用过哪些模板引擎?使用模板引擎的目的是使程序的逻辑代码和html界面代码分离开，是程序的结构更清晰。使用过的模板引擎：Smarty、ThinkPHP的ThinkTemplate 指出以下代码片段中的SQL注入漏洞以及解决方法(magic_quotes_gpc = off)1mysql_query("select id,title from content where catid='&#123;$_GET[catid]&#125;' and title like '%$_GET[keywords]%'", $link); 注入漏洞主要存在用户提交的数据上，这里的注入漏洞主要是$_GET[catid]和$_GET[keyword] 解决注入漏洞：1234567$_GET[catid]=intval($_GET[catid]);$sql="select id,title from content where catid='&#123;$_GET[catid]&#125;' and title like '%$_GET[keywords]%";$sql=addslashes($sql);mysql_query($sql); MyISAM 和 InnoDB 的基本区别?MYISAM不支持外键和事务处理，采用表锁机制，查询速度稍快，数据存储文件有3个，InnoDB支持外键和事务处理，采用行锁机制，查询速度比MYISAM稍慢，数据存储文件只有一个。 写出匹配URL的正则表达式./^http:\/\/www.([\w]+).([\w]+)$/ 写一个函数实现字符串翻转方法一：strrev(‘abcdef’);方法二：12345678910function str($a)&#123; $len = strlen($a); $b = ""; for($i = $len-1; $i &gt;= 0; $i--) &#123; $b .= $a[$i]; &#125; return $b;&#125;echo str('abcdef'); 不断在文件hello.txt头部写入一行“Hello World”字符串，要求代码完整1234567891011$fp=fopen('hello.txt', 'r');$str='hello!'."\n";$str.=fread($fp, filesize('./hello.txt'));fclose($fp);$fp1=fopen('hello.txt', 'w');fwrite($fp1, $str);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建SVN服务器]]></title>
      <url>%2F2017%2F02%2F26%2Fserver-build-svn%2F</url>
      <content type="text"><![CDATA[在 Centos5.5 上搭建SVN服务器并实现自动同步至web目录。 一、搭建svn环境并创建仓库：安装Subversion1yum install -y subversion 检测是否安装成功(查看svn版本号)1svnserve --version 创建版本库（没有规定在哪创建目录）12345mkdir /home/svn //先建目录cd /home/svn //进入目录svnadmin create /home/svn/test //创建版本库cd test //进入创建的版本库ls //会看到自动生成的版本库文件（如下图） 创建用户组及用户进入版本库中的配置目录conf 修改权限配置文件1vim authz 配置用户名命令文件1vim passwd 配置SVN服务综合配置文件1vim svnserve.conf //找到以下配置项，将前面的#号去掉（注意：所有配置项前面不能留空格），然后做相应的配置anon-access = none //匿名用户访问权限:无auth-access = write //普通用户访问权限:写password-db = passwd //引入密码文件authz-db = authz //引入权限配置文件realm = /home/svn/test //版本库所在 启动svn服务1svnserve -d -r /home/svn 其中 -d表示(独立端口运行) -r表示(仓库地址)svn服务走svn协议，端口号是3690 如果提示：svnserve: E000098: Can’t bind server socket: Address already in use证明现在svn已经被启动了，由于我们修改了配置文件，因此要重启svn服务，所以要先关闭svn再重启svn 查看svn服务详情（如下图所示）1ps aux | grep svn 将svn服务强制停止 其中790为svn服务的ID号，-9是kill的参数1kill -9 790 最后再重新运行 svnserve -d -r /var/svn 测试有没有成功123cd /wwwmkdir testsvn co svn://localhost/test /www/test --username vonfly(SVN账号) --password vonfly(SVN密码) 如果提示：Checked out revision 0.表示checkout成功 本地拉取、推送（本地要先安装SVN客户端）输入远程链接：svn://服务器iP地址/test，再输入用户名和密码即可链接 本地commit时自动同步到web目录实现本地更新同步到服务器项目：配置项目仓库的钩子配置,可以把钩子看成是WEB项目于SVN项目仓库之间的一个关联，通过向SVN项目仓库提交脚本代码，利用钩子shell脚本可以自动向web项目中将脚本文件更新过去 进入/var/svn/project/hooks下，建立post-commit文件12cd /var/svn/project/hooksvim post-commit 在该文件里添加如下代码： #!/bin/shexport LANG=zh_CN.UTF-8SVN_PATH=/usr/bin/svn //这里不用改WEB_PATH=/www/test //对应自己web目录//这里的用户随便一个就好$SVN_PATH update $WEB_PATH –username ‘vonfly’ –password ‘vonfly’ –no-auth-cache 给post-commit 执行权限1chmod 755 post-commit 扩展具体权限表示r(read)读【有update操作】 w(write)写【有commit操作】 开启只操作某个目录的权限要求：给帐号设置只操作temp目录的权限，只能给操作temp目录的用户只读权限对应的权限文件（authz）设置[test:/temp]temp1 = rtemp2 = r…..对应的本地客户端拉取就要：输入远程链接：svn://服务器iP地址/test/temp说明：这样的设置不会影响到之前[test:/]的设置，两个设置可以共存]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime使用技巧]]></title>
      <url>%2F2017%2F02%2F17%2Fsublime%2F</url>
      <content type="text"><![CDATA[sublime使用技巧，平时用的时候觉得不错的功能就会把它分享给大家(●’◡’●) sublime右键快捷方式添加window下，开始-&gt;运行-&gt;regedit到 HKEY_CLASSES_ROOT*\shell目录下新建sublime(随便你起什么名字)再到新建好的sublime目录下新建command(固定名字) 最后的目录结构【HKEY_CLASSES_ROOT*\shell\sublime\command】 第一个双引号是你的软件安装目录“E:\Sublime Text 3 Build 3103 x64 Portable Cracked (2016.02.11)\sublime_text.exe” -p –remote-tab-silent “%1” window如何查看软件安装目录，如下图说明： 选中上一步建好的文件command，然后双击右边的默认，把上边的内容复制进去即可。如下图说明 随便找个文件sublime能够识别的文件，鼠标右击就可以看到刚刚添加的快捷键了，可以直接打开 Sublime text 2/3 中 Package Control 的安装与使用方法从菜单 View - Show Console 或者 ctrl + ~ 快捷键，调出 console。将以下 Python 代码粘贴进去并 enter 执行，不出意外即完成安装。以下提供 ST3 和 ST2 的安装代码： Sublime Text 3：1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) Sublime Text 2：1import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation') 常用的一些插件：AdvancedNewFile 快速创建新文件Better Completion 全能代码提示(需要自己配置一下插件，需要提示的库)CodeFormatter 代码格式化ConverToUTF8 支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件DocBlockr 代码块注释EmmetFile Header 自动更新保存时间，文件模板Side BarMonokai Extended 主题配置SideBarEnhancements 增强型侧边栏]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[收集、总结的一些理论知识（对于面试有帮助）]]></title>
      <url>%2F2017%2F02%2F09%2Ftheoretical-knowledge%2F</url>
      <content type="text"><![CDATA[本页面主要用于编写一些理论知识，从网上找的或者自己总结的都会有。为什么要写这个页面呢？一来自己的理论知识相对比较薄弱，每次面试的时候，有很多理论知识都回答不上，所以要加深巩固自己的理论知识。二来自己写一遍或者抄一遍总会有点印象，对以后的工作多多少少会有点帮助(●’◡’●) javascript理论知识xml与json区别相同点： 都是一种通用协议 都可以用来描述数据 不同点： JSON相对于XML来讲，数据的体积小，传递的速度更快些。 xml专用带宽大，json占用带宽小 json没有xml这么通用 json可以和js对象互相转换，和js是天生的一对，因此广泛用于前端开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识gulp]]></title>
      <url>%2F2016%2F11%2F02%2Fgulp%2F</url>
      <content type="text"><![CDATA[初识gulp自动化构建工具。一开始只是听过这个东西，没有尝试用过。听起来好像很高大上的样子，一直想要去尝试用一下，但一直没有去用过。一来现在的项目没有用到；二来之前好像确实是挺忙的，没有找到什么合适的时间去尝试用下；三来嘛感觉这么高大上的东西可能学起来应该会很难，会花费很多时间。ps：很多事情只有去尝试了才会知道难不难，很多东西你觉得难可能是因为你没有用过它，或者不知道它是用来做什么的，只有你勇敢的踏出一步去尝试用下，你就会发现其实没有那么难。(●’◡’●) 介绍通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 入门指南 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件：var gulp = require(‘gulp’); gulp.task(‘default’, function() { // 将你的默认的任务代码放在这}); 运行 gulp：1$ gulp default 如博客gulpfile.js代码为:123456789101112var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task("minhtml",function()&#123; return gulp.src("public/**/*.html") .pipe(htmlmin()) .pipe(gulp.dest("./public"))&#125;); 常用的一些插件 gulp-minify-css 压缩css gulp-uglify 压缩js gulp-htmlmin 压缩html gulp-imagemin 压缩图片安装1$ npm install [plugins-name] --save 上述命令安装插件的同时也会把插件作为项目依赖写入package.json文件. 参考：guly官网(包含插件搜索)guly中文网站]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些常用的linux-commands]]></title>
      <url>%2F2016%2F09%2F06%2Flinux-commands%2F</url>
      <content type="text"><![CDATA[常用的一些Linux命令 目录操作查看目录下的文件123lsls -l //显示文件的详细信息(包括权限信息)ls -al //显示文件的详细信息(包括隐藏文件) 目录切换1cd 目录名字 创建目录12mkdir newdir1 //创建单个新目录mkdir -p newdir1/newdir2/newdir3 //递归创建多级目录 移动目录12mv dir1 dir2 //dir1目录移动到dir2的目录下mv dir1 newdir //dir1移动到当前目录下，并改名字为newdir 复制（复制目录一般要加-R参数）12cp -R dir1 newdir //dir1复制到当前目录，并改名字为 newdircp file dir1 //file文件复制到dir1下 删除12rm file //删除file文件rm -rf dir //递归强制删除目录 查看当前操作目录位置1pwd 文件操作文件内容查看123456cat filename //一次性把全部内容输出到终端more filename //通过敲回车方式逐行查看文件内容，q键结束查看less filename //&quot;上下左右&quot;键方式查看文件各部分内容，q键结束查看head -n filename //查看文件的前n行内容tail -n filename //查看文件的最后n行内容wc filename //查看文件内容行数 创建文件1touch filename //在当前目录创建filename文件 给文件追加内容123echo 内容 &gt; 文件 //把内容以覆盖写方式添加到文件中echo 内容 &gt;&gt; 文件 //把内容以追加方式添加到文件中//例：echo vonfly &gt; test 说明：如果文件不存在会自动创建 文件主人、组别设置12chown 主人 filenamechown 主人.组别名称 filename ##组和用户的操作 组的操作对应配置文件：/etc/group12groupadd 组名 //创建组（例：groupadd php）创建php这个组groupmod -n 新组名 原组名 //修改组（例：groupmod -n php python）把php这个组修改成python 用户的操作对应配置文件：/etc/passwd123useradd -g 组编号 用户名 //创建用户，顺便分组usermod -l 新用户名 原用户名 //修改用户名userdel -r 用户名 //删除用户信息同时删除用户家目录 设置用户密码1passwd 用户名 //例：passwd vonfly (给vonfly设置新密码) 权限操作字母相对方式设置权限12chmod u+/-rwx,g+/-rwx,o+/-rwx filename //主人，同组用户，其他组用户增加或减少权限，可以设置一个或多个权限chmod +w,-x filename //统一给每一个组别设置统一权限（相当于给主人，同组用户，其他组用户增加了读的权限，减少了执行的权限） 数字绝对方式设置权限（会直接覆盖之前的权限）12chmod 621 filename //表示给主人设置成读写权限，同组用户设置写权限，其他组用户设置执行权限chmod -R 777 dirname //-R参数表示递归方式设置目录权限 说明：读：4，写：2，执行：10表示没有权限1表示执行权限2表示写权限3表示写、执行权限4表示读权限5表示读、执行权限6表示读、写权限7表示读、写、执行权限 文件的读写执行具体表示：读：表示是否可以查看文件内容写：表示是否可以修改该文件执行：一般表示执行shell脚本程序文件 目录的读写执行具体表示：读：表示是否可以查看该目录下的文件信息写：表示是否可以给该目录创建、删除文件执行：表示用户是否可以通过cd进入该目录 find文件查找指令参数说明 选项 描述 -name 根据文件名字查找文件 -size 根据文件大小查找文件 -maxdepth 限制最深层次查找文件 -mindepth 限制最浅层次查找文件 -perm 把符合某个权限的文件给查找出来 -user 根据主人查找文件 -group 根据组别查找文件 例子： 123456789find /home -name vonfly //在home目录下查找vonfly文件find /home -name &quot;v*&quot; //在home目录下模糊查找带v字符开始的文件find /home -size 100c //在home目录下找大小为100字节的文件find /home -size 100 //在home目录下找大小为100*512字节的文件find /home -size +10k //在home目录下找大小大于10的文件find /home -size -10k //在home目录下找大小小于10的文件find /home -maxdepth 3 -name vonfly //在home目录下限制最深为3个目录层次，进行vonfly文件查找 其它操作查看指令可以使用的参数1man 指令名称 //例：man useradd 用户切换123su - //切换到root超级管理员su vonfly //切换到vonfly普通用户exit //退回到原用户 说明：一般su和exit是配对使用的，否则用户切换会叠加 查看当前用户是谁12whoami //显示当前正在操作系统的用户who am i //显示登录系统的用户 查看指令对应的可执行(二进制)文件位置1which 指令名称 (如：which pwd) 查看系统活跃的进程12ps -Aps -aux 将文本指定的信息匹配出来1grep 关键字 文件的路径 //例：grep php ./test.txt 表示在当前文件test.txt中找php关键字 通过进程名称来查询程序(如mysql)是否有启用（管道使用）12ps aux | grep mysqlpstree -p | grep mysql //方法2 通过端口查看程序是否有启用（管道使用）123netstat -anpl | grep 3306 //查看mysql（默认监听3306端口）netstat -anpl | grep 9000 //查看php（默认监听9000端口）netstat -tunpl | grep :3306 //方法2 查看系统分区情况12df -lhdf -h 查看目录或者文件的大小1du -h filename 关闭指定进程号的进程12kill -9 pid //强制关闭kill -15 pid //正常关闭 查看内存使用1free -m 查看CPU使用1top 关机1shutdown -h now 可以切换终端1alt+f(1-6),共有6个终端 实时跟踪一个命令的执行结果(如跟踪ls -lh命令)12可以切换终端来查看具体效果watch -n1 ls -lh 加压方式12.tar.gz------------------&gt; tar zxvf 压缩包名.tar.gz.tar.bz2-----------------&gt; tar jxvf 压缩包名.tar.bz2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些常用的git-commands]]></title>
      <url>%2F2016%2F06%2F18%2Fgit-commands%2F</url>
      <content type="text"><![CDATA[常用的一些git命令以及平时项目遇到的一些问题解决方法 git一些命令在当前目录新建一个Git代码库1$ git init 新建一个目录，将其初始化为Git代码库 1$ git init [project-name] 下载一个项目和它的整个代码历史 1$ git clone [url] 增加/删除文件添加指定文件到暂存区1$ git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录1$ git add [dir] 将所有修改过的工作文件提交暂存区1$ add . 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交1$ git add -p 删除暂存区文件1$ git rm file.name (工作区和暂存区都存在的情况下)删除工作区文件，同时删除暂存区文件1$ git rm -f file.name (工作区和暂存区都存在的情况下)不删除工作区文件，删除暂存区文件1$ git rm --cached file.name 改名文件，并且将这个改名放入暂存区1$ git mv [file-original] [file-renamed] 代码提交提交暂存区到仓库区（提交说明要用英文引号）1$ git commit -m [提交说明] 提交暂存区到仓库区1$ git commit [file1] [file2] ... -m [提交说明] 分支列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支，但依然停留在当前分支1$ git branch [branch-name] 新建一个分支，并切换到该分支1$ git checkout -b [branch] 新建一个分支，指向指定commit1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit，合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 查看信息显示有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示之后版本历史1$ git reflog 显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示某个文件的版本历史，包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --oneline 显示指定文件是什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 显示两次提交之间的差异1$ git diff [first-branch]...[second-branch] 远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库，并命名1$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 整个版本的撤销重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard [commit] 显示当前的Git配置1$ git config --list 编辑Git配置文件1$ git config -e [--global] 设置提交代码时的用户信息12$ git config [--global] user.name "your username"$ git config [--global] user.email "your e-mail" 扩展多人协作解决冲突推荐方法1：123$ git fetch$ git diff master origin/master$ git merge orgin/master 方法2：1$ git pull 参考：阮一峰-常用 Git 命令清单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多台电脑共同管理hexo博客]]></title>
      <url>%2F2016%2F02%2F18%2Fhexo-version-control%2F</url>
      <content type="text"><![CDATA[使用hexo搭建博客，如果换了电脑怎么更新博客？如果你有备份源文件那还好，但是每次都要备份感觉太麻烦了。这里介绍一种方法就是使用github分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。网上也有其他的方法，大家可以去搜一下，自己看看哪种适合自己，我用这种方法一方面我git命令也不太熟，所以想多写写，多学学。 先删除主题文件下的.git文件，可以直接删除或者执行下面的命令 1$ rm -rf .git 然后在本地博客文件夹下边依次输入以下指令(部分指令因为有提示可以自己修改下) 123456$ git init$ git checkout -b hexo$ git remote add origin git@github.com:vonfly（你自己giuhub账号名）/vonfly.github.io（项目名）.git$ git add .$ git commit -m "提交说明"$ git push origin hexo 执行到这里我们就已经把本地的源文件添加到了分支hexo上。 说明：博客文件夹下根目录.gitignore（此文件的作用是因此忽略所写的文件或者目录，加快push速度。）可以不修改，我的就没有修改，如果不修改的话在；另外一台电脑上克隆下来的博客项目就要先运行一下命令 1$ npm install 我的.gitignore文件内容为.DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 当然你也可以把node_modules/去掉，这样在另外的电脑克隆下来的项目就不用在运行上面的命令了 扩展： github常见操作和常见错误！如果输入$ git remote add origin git@github.com:vonfly（github帐号名）/vonfly.github.io（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git 就不会报错了！ 如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容4、找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！ 如果输入$ git push origin master提示出错信息：error:failed to push som refs to …….解决办法如下： 1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来 2、再输入$ git push origin master 3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository. 4、则需要重新输入$ git remote add origin git@github.com:vonfly/vonfly.github.io.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用的一些命令]]></title>
      <url>%2F2016%2F02%2F16%2Fcommon-commands%2F</url>
      <content type="text"><![CDATA[平时写博客会用到的一些命令 hexo命令init 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。1$ hexo init [folder] new 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。1$ hexo new [layout] &lt;title&gt; generate 生成网站(即生成静态文件)1$ hexo generate 参数说明 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。1$ hexo server 参数说明 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日志记录，使用覆盖记录格式 deploy 部署网站。1$ hexo deploy 参数说明 选项 描述 -g, –generate 部署之前预先生成静态文件 clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。1$ hexo clean version 显示 Hexo 版本。1$ hexo version 安装 Hexo Algolia 扩展（用于页面搜索）1$ npm install hexo-algolia@0.2.0 来更新 Index（相当于把博客下的文章更新到algolia数据库）1$ hexo algolia]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown语法-本页面主要用于自己学习]]></title>
      <url>%2F2016%2F02%2F07%2Fmarkdown-grammar%2F</url>
      <content type="text"><![CDATA[本页面主要用于自己学习的，方便以后写作。当然了，偶尔忘记可以查看一下，文章最底下也有链接，大家可以查看链接的语法说明(●’◡’●) 欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 参考：Cmd Markdown 编辑阅读器Markdown 语法说明 (简体中文版)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub+Hexo+Next搭建免费独立个人博客]]></title>
      <url>%2F2016%2F01%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[我为什么要搭建个人博客呢，一来有自己的博客会显得高大尚一点，二来也可以当作学习新知识 搭建步骤node.js Git 是必须工具 安装Git前往Git官网下载Windows版本压缩包，下载完成后解压安装。（一直下一步即可） 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：在命令行中输入：12$ git config --global user.name "your username"$ git config --global user.email "your e-mail" 重申一遍，你只需要做一次这个设置。如果你传递了 –global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。 安装Node.js前往Node.js官方下载网站，选择适合自己系统的进行下载，下载完成后同样解压安装。（一直下一步即可） 注册Github账户前往Github网站，注册一个新用户。创建一个新的repository 在自己的Github主页右上角的加号,创建一个新的repository。比如我的Github用户名为vonfly，那么我创建的repository的名字应该是 vonfly.github.io 给本机配置SSH-Key打开Git Bash，在命令行中输入： 1$ ssh-keygen -t rsa -C "your e-mail" 之后一直回车，就可以了成功之后在命令行中找到这两段Your identification has been saved in /c/Users/XZY-06/.ssh/id_rsa.Your public key has been saved in /c/Users/XZY-06/.ssh/id_rsa.pub.打开所对应的文件夹，找到 id_rsa.pub文件，用编辑器打开，复制其中的全部内容。登陆你的GitHub账户，依次点击账号Settings &gt; SSH and GPG keys &gt; new SSH key，把id_rsa.pub中的内容拷贝进去key项，title项随意填 。 至此就已经配置完SSH-Key了 安装Hexo（安装需要花一些时间）点击鼠标右键，看是否有Git bash Here选项。如果没有可以前往Git安装根目录，启动git-base.exe也可以。在命令行中输入： 1$ npm install -g hexo-cli 创建myblog文件夹找到想要放置博客的文件夹，比如（F:\myblog），在该目录下鼠标右击打开Gitbash工具。在命令行中输入： 1$ hexo init 这里init后面可以跟文件目录，比如我想在F:\text下创建博客文件夹，那么可以用下面的命令： 1$ hexo init F:\text 安装依赖包在myblog目录下，执行以下命令 1$ npm install 安装完后的目录结构123456├── _config.yml //网站的配置信息（也就是站点配置文件）├── package.json //应用程序数据，指明hexo的版本等信息├── scaffolds //模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source //文章源码目录，该目录下的markdown和html文件均会被hexo处理。| ├── _posts //新建的文章都将存放在此目录下。编辑&lt;文件名&gt;.md文件可修改内容。└── themes //主题文件夹。Hexo会根据主题来生成静态页面。 本地调试（在myblog目录下，依次执行以下命令）1.生成网站1$ hexo generate 2.本地服务器1$ hexo server 然后在浏览器中输入 localhost:4000 就可以看到自己的博客了如果打开很慢或者打开不了，可以更改下端口1$ hexo server -p 3000 重新在浏览器中输入 localhost:3000即可，至此我们已经搭建好自己的Hexo博客了，不过博客采用的主题是默认的主题，而我们要使用简洁优雅且易于使用NexT主题 Next主题1.下载Next主题（下载需要一点时间）在myblog目录下，执行以下命令 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用Next主题下载完成后，打开站点配置文件(即更目录下的_config.yml)，找到theme字段，并将其值更改为 next。再重新执行本地调试那一步骤的命令查看效果即可 将本地的文件部署（上传）到Github账户中打开站点配置文件(即更目录下的_config.yml)，在最后添加如下代码（在你修改时，把 repository更换成之前步骤创建新的repository仓库地址） 1234deploy: type: git repository: https://github.com/vonfly/vonfly.github.io.git branch: master 执行以下指令即可完成部署（如果提示错误，可以看下面出错原因及解决方法）： 12$ hexo generate$ hexo deploy 1.每次修改本地文件，都需要命令$ hexo generate才能保存。而且每次使用命令都必须在myblog根目录下使用。 2.如果你在执行$ hexo deloy,如果提示 ERROR Deployer not found: git，那说明你没有安装hexo-deployer-git依赖包，进入F:\Hexo\node_modules发现真的没有hexo-deployer-git。解决方法：①只需要输入下面命令创建hexo-deployer-git依赖包 1$ npm install hexo-deployer-git --save ②然后再执行hexo deploy就能上传成功了1$ hexo deploy 直接在浏览器访问vonfly.github.io试试 博客安装和主题配置参考：hexo官网next主题官网]]></content>
    </entry>

    
  
  
</search>
